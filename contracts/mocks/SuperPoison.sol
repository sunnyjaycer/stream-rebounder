//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;

import {
    ISuperToken,
    CustomSuperTokenBase
} from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/CustomSuperTokenBase.sol";
import {UUPSProxy} from "@superfluid-finance/ethereum-contracts/contracts/upgradability/UUPSProxy.sol";
import {FixedSizeData} from "@superfluid-finance/ethereum-contracts/contracts/libs/FixedSizeData.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Pure Super Token that gets apps jailed.
/// @author NOT a robot
/// @dev Notice this is a standard UUPS Proxy, per the Superfluid recommendations. The only major
/// change here is the `updateAgreementData` called by agreements can conditionally revert if an
/// attacker wishes. Everything else functions as a standard pure super token.
contract SuperPoison is CustomSuperTokenBase, UUPSProxy {

    /// @notice ISuperfluidToken.AgreementUpdated
    /// @dev Agreement updated event
    /// @param agreementClass Contract address of the agreement
    /// @param id Agreement ID
    /// @param data Agreement data
    event AgreementUpdated(
        address indexed agreementClass,
        bytes32 id,
        bytes32[] data
    );

    /// @notice Flow ID generated by any two addresses
    bytes32 internal _poisonFlowId;

    /// @notice Pure Super Token initializer.
    /// @param name Name of Super Token.
    /// @param symbol Symbol of Super Token.
    function initialize(
        string calldata name,
        string calldata symbol
    ) public {
        ISuperToken(address(this)).initialize(
            IERC20(address(0)),
            18,
            name,
            symbol
        );
        ISuperToken(address(this)).selfMint(msg.sender, 1 ether, new bytes(0));
    }

    /// @notice Sets a poison Flow ID to jail app
    /// @param sender Address of flow sender to jail on termination (super app).
    /// @param receiver Address of flow receiver to jail on termination (attacker).
    function setPoisonFlowId(address sender, address receiver) public {
        // Generates the flow ID.
        // https://github.com/superfluid-finance/protocol-monorepo/blob/75a000190fcfb12a8fee6da5b1a2fe198e4f518c/packages/ethereum-contracts/contracts/agreements/ConstantFlowAgreementV1.sol#L1327
        _poisonFlowId = keccak256(abi.encode(sender, receiver));
    }

    /// @notice Defined in `SuperfluidToken.sol`.
    /// @param id Agreement ID (flow id).
    /// @param data Agreement data (all zeros if termination)
    function updateAgreementData(bytes32 id, bytes32[] calldata data) public {
        _tryBreakApp(id, data);
    
        address agreementClass = msg.sender;
        bytes32 slot = keccak256(abi.encode("AgreementData", agreementClass, id));
        FixedSizeData.storeData(slot, data);
        emit AgreementUpdated(msg.sender, id, data);
    }

    function _tryBreakApp(bytes32 flowId, bytes32[] memory data) internal view {
        // if the flow id matches the poison id AND the flow data is all zeroed out (deletion),
        // we revert and force the app to go to jail.
        if (flowId == _poisonFlowId && data[0] == bytes32(0)) revert("go to jail");
    }
}
